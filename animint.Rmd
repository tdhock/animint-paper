---
title: "Extending ggplot2 for linked and dynamic web graphics"
documentclass: article
fontsize: 12pt
geometry: margin=1in
linkcolor: cyan
citecolor: black
bibliography: refs.bib
abstract: Interactive web graphics are great for communication and knowledge sharing, but are difficult to leverage during the exploratory phase of a data science workflow. Even before the web, interactive graphics helped data analysts quickly gather insight from data, discover the unexpected, and develop better model diagnostics. Web technologies, however, are not designed to fit inside an exploratory data analysis workflow where rapid iteration between data manipulation, modeling, and visualization must occur. We propose the R package **animint** for rapid creation of linked and animated web graphics through a simple extension of **ggplot2**'s implementation of the Grammar of Graphics. The extension allows users to use their existing **ggplot2** code, then leverage an idomatic API for describing animations and graphical queries between multiple linked views.
keywords: Animation, Multiple linked views, Statistical graphics, Exploratory data analysis, Web technologies
output:
  bookdown::pdf_book:
    template: jcgs-template.tex
    toc: no
    keep_tex: yes
    citation_package: none
---


# Introduction {#intro}

<!--
%% In general, there are three influential roles involving an Animint
%% visualization: the developer, who implements the Animint library; the
%% designer, who uses the Animint library to define a visualization; and
%% the user, who selects data subsets to view in a web browser. The main
%% goal of Animint is to provide an expressive language for designers,
%% while allowing users the freedom to interact with the plot to
%% selectively view data subsets of interest. The designer specifies data
%% sets and maps variables to interactive visual elements using the
%% Animint DSL, then uses the Animint library to compile and save an
%% interactive animation. The user writes no code, but can view and
%% interact with an Animint visualization by clicking Scalable Vector
%% Graphics (SVG) elements in a web browser. The Animint library
%% developer is responsible for the plot rendering details, which allows
%% the others to focus on designing and consuming visualizations.

<<opts, echo=FALSE, message=FALSE, cache=FALSE>>=
knitr::opts_chunk$set(tidy = FALSE, eval = FALSE)
knitr::opts_knit$set(out.format = "latex")
knitr::knit_theme$set("edit-matlab")
@


%%Interactive and dynamic statistical graphics toolkits play an important role in the exploratory phase of a data analysis cycle. The web is an attractive platform for interactive graphics thanks to its portability and accessibility, but due to a lack of tools for quick iteration, web graphics are not a practical tool for exploring data. Instead, they are mostly used for the presentation of findings (i.e., when the 'correct' visualization is already known). This is a source of conflict, as one often needs different tools depending on whether the work is exploratory or intended for public consumption, which results in wasted effort.

%%The R package \texttt{ggplot2} is a popular tool for data visualization due in part to its elegant design inspired by the grammar of graphics. The fundamental concept in the grammar of graphics is that any graphic can be described through a set of mappings from data variables to visual space, referred to commonly as \texttt{aesthetic} mappings. The grammar of graphics and ggplot2 were designed for static graphics
-->

For more than a half century now, statisticians have explored how interactive
graphics can inform the modeling process and extract information from data.
In fact, the ASA maintains a thorough video library demonstrating applications
of influential interactive statistical graphics systems such as 
`PRIM-9` [@PRIM9], `Dataviewer` [@viewing-pipeline], `XGobi` [@xgobi], 
`GGobi` [@ggobi:2007], and `Mondrian` [@mondrian]. These, as well as other 
influential systems, such as `LISP-STAT` [@LISP-STAT] and `MANET` [@MANET], 
all have a rich environment for accomplishing a wide variety of statistical 
analysis tasks, and most were developed before the web browser had rich 
support for graphics.


@Cook:2007uk 


Interactive graphics are an important part of applied statistical
practice, because they can lead to a better understanding of
high-dimensional data sets and models. Interactive graphics are useful
in the context of EDA, model selection/validation, and presenting
results of an analysis. Interactive graphics toolkits in R have been
available for decades, but these approaches are often not easy to
reproduce or distribute to a larger audience. It is true that most
graphics generated during EDA are ultimately not useful, but
sometimes, understanding gained during this phase is most easily
shared via the interactive graphics themselves. Thus, there is value
in being able to easily share and embed interactive graphics inside a
larger report. Unfortunately, this is typically hard, if not
impossible, using traditional interactive graphics toolkits. As a
result, there is a large disconnect between the visualization tools
that we use for exploration versus presentation.

One of the most widely used R packages is **ggplot2** [@ggplot2-book], a data
visualization package inspired by the grammar of graphics [@wilkinson]. 
In fact, @Donoho:2015tu writes: "This effort may have more impact on 
todayâ€™s practice of data analysis than many highly-regarded theoretical 
statistics papers". In our experience, **ggplot2** has made an impact thanks to its
foundation in the grammar of graphics, carefully chosen defaults, and overall
usability. This helps data analysts rapidly iterate and discover informative
visualizations -- an essential task in exploratory data analysis (EDA). When 
dealing with high-dimensional data, however, it is often useful to produce 
interactive and/or dynamic graphics, which **ggplot2** does not inherently support. 

<!--
%%Since the design space of interactive and dynamic graphics is so large, however, it is extremely difficult to design an fully featured interface that is useful in a EDA setting.
-->



We aim to narrow this gap in visualization tools by extending **ggplot2**'s grammar 
of graphics implementation for interactive and dynamic web graphics. Our 
extension allows one to create animated transitions
and perform dynamic queries via direct manipulation of linked views like those
described in @Ahlberg:1991 and @Buja:1991vh. 
A conceptual model for our extension is provided in
Section \@ref(extension) and Section \@ref(animation). In 
Section \@ref(worldbank), we demonstrate our extension with an example. 
In Section \@ref(implementation), we outline design decisions made in our
implementation in the R package **animint**. In Section \@ref(performance), we
provide a sense of the scope of our system and its performance limitations through a
handful of examples. In Section \@ref(compare), we conduct a comparison
study by replicating examples with other leading systems. Finally, in 
Section \@ref(limitations), we discuss future work and limitations of
our current system.

# Related work

We aim to provide a system which empowers **ggplot2** users to go beyond the 
confines of static graphics with minimal friction imposed upon their current
workflow. We acknowledge that numerous systems which support similar 
visualization techniques exist outside of the R ecosystem, but we 
intentionally focus on R interfaces since the surrounding statistical 
computing environment is crucial for enabling an efficient EDA workflow.

It is important to acknowledge that **ggplot2** is built on top of the R package 
**grid**, a low-level graphics system, which is now bundled with R itself 
[@RCore]. Neither **grid**, nor **base** R graphics, have strong support for 
handling user interaction, which creates a need for add-on packages. There are a 
number of approaches these packages take to rendering, each with their own 
benefits and drawbacks. Traditionally, they build on low-level R interfaces 
to graphical systems such as GTK+ [@RGtk2], Qt [@qtbase], or Java GUI frameworks 
[@rJava]. In general, the resulting system can be 
very fast and flexible, but sharing and reproducing output is usually a problem 
due to the heavy software requirements. Although there may be sacrifices in
performance, using the modern web browser as a canvas is more portable, 
accessible, and composable (graphics can be embedded within larger 
frameworks/documents).



Base R does provide a Scalable Vector Graphics (SVG) device, `svg()`,
via the Cairo graphics API [@cairo]. The R package **SVGAnnotation**
provides functionality to post-process `svg()` output in order to add
interactive and dynamic features [@SVGAnnotation]. This is a powerful
approach, since in theory it can work with any R graphic, but the
package is self-described as a proof-of-concept which
reverse-engineers poorly-structured `svg()` output. As a result, it is
not straightforward to extend this system for linked data
visualizations with advanced functionality (multiple layers, multiple
plots, multiple selection variables).

The lack of well-structured SVG for R graphics motivated the **gridSVG** package 
which provides sensible structuring of SVG output for grid graphics 
[@gridSVG]. This package also provides some low-level tools for animating 
or adding interactive features, where grid objects must be referenced by name.
As a result, use of this interface to add interactivity to a 
**ggplot2** plot requires understanding of the grid naming scheme **ggplot2** uses 
internally. An interface where 
interactivity can be expressed by referencing the data to be visualized, 
rather than the building blocks of the graphics system, would be preferable 
since the former interface is decoupled from the implementation and does not 
require knowledge of grid.

In terms of the animation API, the R package **gganimate** is very similar to our
system [@gganimate]. It directly extends **ggplot2** by adding a new aesthetic,
named `frame`, which splits the data into subsets (one for each unique 
value of the frame variable), produces a static plot for each subset, and uses
the animation package to combine the images into a key frame animation 
[@animation]. This is quite similar but not as flexible as our system's
support for animation, which we fully describe in Section \@ref(animation).
Either system has the ability to control the amount of time that a given frame 
is displayed, but our system can also animate the transition between frames via
the `d3.transition()` API [@d3]. Smooth transitions help the animation viewer track
positions between frames, which is useful in many scenarios, such as the 
touring example discussed in Section \@ref(tour). 
The **tweenr** package provides similar smooth transitions, 
by computing data values in R that interpolate between 
animation frames (in **animint**, these calculations are performed in the web browser).

The **ggvis** package is similar to our system in that is is also inspired
by the grammar of graphics [@ggvis]. It does not directly extend
**ggplot2**, but instead provides a brand new purely functional interface
which is designed with interactive graphics in mind. It currently
relies on Vega to render the SVG graphics from JSON [@vega], and the R
package **shiny** to enable many of its interactive capabilities
[@shiny]. The interface gives tremendous power to R users, as it
allows one to write R functions to handle user events. This power does
come with a cost, though, as sharing and hosting ggvis graphics
typically requires special web server softwares, even when the
interaction logic could be handled entirely client-side. As we outline
in Section \@ref(implementation), our system does not require a web
server, but can also be used inside **shiny** web applications, when
desired.

The tour is a useful visualization technique for exploring high-dimensional data
which requires interactive and dynamic graphics. The open-source software ggobi 
is currently the most fully-featured toolkit for touring data and has support
for interactive techniques such as linking, zooming, panning, and identifying 
[@ggobi:2007]. The R package **rggobi** [@rggobi] provides an R interface 
to ggobi's graphical interface, but unfortunately, the software requirements 
for installation and use of this toolchain are heavy and stringent. Furthermore,
sharing the interactive versions of these graphics are not possible. The R 
package **cranvas** aims to be the successor to ggobi, with support for similar
interactive techniques, but with a more flexible interface for describing 
plots inspired by the grammar of graphics [@cranvas]. **Cranvas** also has 
heavy and stringent software requirements which limits the portability and
accessibility of the software. 

Another R package for interactive graphics is **iplots** [@Urbanek2011],
which has several important differences compared to  **animint**. 
Brushing/highlighting of linked iplots is supported for
single-layer plots such as scatterplots or barplots, but it is not
easy to define new multi-layer interactive plots. Futhermore since
iplots does not use the grammar of graphics, it is difficult to create
legends and multi-panel plots. Finally since iplots requires compiled
C++ code for rendering on the local machine, its graphics are not as
easy to share as **animint** graphics which can be viewed in a web
browser.


# Extending the layered grammar of graphics

\begin{table}

\caption{
New features that animint adds to the grammar of graphics.
}\label{tab:overview}
\small
\begin{tabularx}{\textwidth}{rl}
Feature & Description \\
\hline
clickSelects & aesthetic for a geom which can be clicked to update the current selection.  \\
showSelected & aesthetic for a geom which plots only the data corresponding to the current selection.  \\
selector.types & global option to specify single or multiple selection for each interaction variable.  \\
first & global option to specify first selection.  \\
time & global option to specify delay between animation frames.  \\
duration & global option to specify smooth transitions.  \\
\hline
\end{tabularx}

\end{table}


In this section, we propose several extensions to the layered grammar of graphics
(Table~\@ref(tab:overview)). Our extensions enable declarative expression of animations and
dynamic queries via direct manipulation. In **ggplot2**, there are five
essential components that define a layer of graphical makings: data, mappings 
(i.e., aesthetics), geometry, statistic, and position. These simple components 
are easily understood in isolation and can be combined in many ways to express
a wide array of graphics. For a simple example, here is one way to create a
scatterplot in **ggplot2** of variables named `<X>` and `<Y>` in 
`<DATA>`:

```{r, echo = FALSE}
knitr::opts_chunk$set(eval = FALSE, message = FALSE)
```


```{r}
ggplot() + layer(
  data = <DATA>, 
  mapping = aes(x = <X>, y = <Y>), 
  geom = "point", 
  stat = "identity",
  position = "identity"
)
```

For every geometry, **ggplot2** provides a convenient wrapper around 
`layer()` which provides sensible defaults for the statistic and 
position (in this case, both are "identity"):

```{r}
ggplot() + geom_point(
  data = <DATA>, 
  aes(x = <X>, y = <Y>)
)
```

A single **ggplot2** plot can be comprised of multiple layers, and different layers 
can correspond to different data. Since each graphical mark within a **ggplot2** 
layer corresponds to one (or more) observations in `<DATA>`, aesthetic
mappings provide a mechanism for mapping graphical selections to the original 
data (and vice-versa) which is essential to any interactive graphics system [@plumbing]. 
Thus, given a way to combine multiple 
**ggplot2** plots into a single view, this design can be extended to support a 
notion of multiple linked views, as those discussed in @Ahlberg:1991 
and @Buja:1991vh.

## Direct manipulation of dynamic queries {#extension}

Direct manipulation, as discussed in @Ahlberg:1991, is a graphical
interface for interacting with databases. Direct manipulation
interfaces include a graphical representation of queries to the
database, which can be manipulated using the mouse. In the context of
statistical graphics, direct manipulation refers to interfaces in
which clicking the plotted representation of the data (such as lines
or points) changes the plot. In contrast, indirect manipulation
interfaces use widgets (such as buttons or menus) to change the plot.

@ggobi:2007 use SQL queries to formalize the direct manipulation
methods discussed in @Ahlberg:1991 and @Buja:1991vh. We propose to
embed this direct manipulation framework inside the layered grammar of
graphics with two new aesthetics, `clickSelects` and `showSelected`. 

* `clickSelects` defines a selection source via a mouse click. For
  example `aes(clickSelects=year)` designates a plot element which,
  when clicked, will change the selected value of the `year` variable.
* `showSelected` defines a selection target. For example
  `aes(showSelected=year)` means to only show a plot element for data
  with the currently selected value of the `year` variable.

Below, we use **animint** to create a linked view between a bar chart and
a scatter plot, where the user can click on bars to control the points
shown in the scatterplot.  This is shown in the video in Figure
\@ref(fig:tips). As a result, we can quickly see how the relationship
among tip amount and total bill amount depends on whether the customer
is smoker.

```{r}
gg.bar <- ggplot() + geom_bar(
  data = reshape2::tips, 
  aes(x = smoker, clickSelects = smoker)
)
gg.scatter <- ggplot() + geom_point(
  data = reshape2::tips, 
  aes(x = total_bill, y = tip, 
      showSelected = smoker)
)
```

```{r tips, echo = FALSE, eval = TRUE, fig.cap = "Linked dynamic querying via direct manipulation using animint. The `clickSelects` aesthetic designates a clickable geom that can change a selection variable, and the `showSelected` aesthetic designates a geom that responds by showing only the data which corresponds to the current selection. A video demonstration can be viewed online at <https://vimeo.com/160496419>"}
knitr::include_graphics("images/figure-tips")
```

In the R code above, the proposed `showSelected` and `clickSelects`
aesthetics are used to link the two ggplots, since they refer to a
common variable, `smoker`. Each variable that is used in a
`clickSelects` or `showSelected` aesthetic is treated as a selection
variable with an interactively updated set of selected values that is
used to dynamically update the plots in response to user input.  In
the first plot above, we have used `aes(clickSelects=smoker)` to
specify a bar with direct manipulation (mouse clicks on the barplot)
that dynamically changes the `smoker` selection variable. In the
second plot above, we have used `aes(showSelected=smoker)` to specify
that we only want to show data points for the current selection of the
`smoker` variable. In response to a user clicking on the bars in the
first plot, our system essentially performs the SQL query below in
order to generate the data to display in the second plot:

```sql
SELECT * FROM tips
  WHERE smoker IN smoker_selection
```

In this example, `smoker_selection` is either "Yes" or "No" (a single selected value), but as we
show in later examples, `smoker_selection` can also be an array of values (multiple selected values).
Although the `clickSelects` aesthetic is tied to a mouse click event,
other aesthetics could easily be created to support other selection
events, such as hover or click+drag. Statistically speaking, this type
of visualization is useful for navigating through joint distributions
conditional upon discrete values. In this sense, our extension is
closely related to trellis displays [@trellis] and linked scatterplot
brushing [@brushing-scatterplots]. The major differences are that our
conditioning is layer-specific (not plot-specific), is not tied to a
particular geometry, and can be controlled through direct manipulation
or animation controls.

## World Bank example {#worldbank}

<!--
%% In the system we propose, the central concept of interactivity is a
%% selection variable, such as year or region in Figure~1. For each
%% selection variable, one or several values can be selected at a time,
%% e.g. year=1979 and country=\{United States, Vietnam\}.  Like
%% Cleveland's system, we also use enhanced linking to highlight the
%% selected value(s) of each selection variable. In contrast to
%% Cleveland's single rectangular brush that selects points in plots of a
%% single data table, we propose several selection variables in linked
%% plots of several data tables. Linking is accomplished using common
%% names when declaring \texttt{clickSelects} and \texttt{showSelected}
%% selection variables.

%% For example, to declare a clickable plot element that changes the
%% selected value of the year variable, a designer writes
%% \texttt{clickSelects=year} (tallrect in Figure~1). And to show only
%% the data subset for the selected value of year, a designer writes
%% \texttt{showSelected=year} (point and text in Figure~1).

%% Using just the \texttt{clickSelects} and \texttt{showSelected}
%% keywords, a wide variety of interactive visualizations can be
%% defined. To make the selection automatically change over time
%% (animation), a designer may declare one variable as the \texttt{time}
%% variable. Since it is perceptually advantageous to have smooth
%% transitions in data-driven animations \citep{animated-transitions}, a
%% designer may also declare a \texttt{duration} list of selection
%% variables which should have smooth transitions.
-->

Figure \@ref(fig:worldbank) shows an interactive animation of the World Bank
data set created with our **animint** implementation [@WorldBank]. The 
visualization helps us explore the change in the relationship between life 
expectancy and fertility over time for 205 countries. By default, the year 
1979 and the countries United States and Vietnam are
selected, but readers are encouraged to watch the video of the animation 
and/or interact the visualization using a web 
browser.\footnote{\url{http://bl.ocks.org/tdhock/raw/8ce47eebb3039263878f/}}
In the interactive version, the selected value of the year variable is
automatically incremented every few seconds, using animation to
visualize yearly changes in the relationship between life expectancy
and fertility rate.

```{r worldbank, echo = FALSE, eval = TRUE, fig.cap = "An interactive animation of World Bank demographic data of several countries, designed using `clickSelects` and `showSelected` keywords (top).  Left: a multiple time series from 1960 to 2010 of life expectancy, with bold lines showing the selected countries and a vertical grey tallrect showing the selected year. Right: a scatterplot of life expectancy versus fertility rate of all countries. The legend and text elements show the current selection: year=1979, country={United States, Vietnam}, and region={East Asia & Pacific, North America}"}
knitr::include_graphics("images/figure-1")
```

We anticipate that some **ggplot2** users will be able to reverse engineer the
**animint** code which creates Figure \@ref(fig:worldbank), simply by looking at it.
In fact, this is a big reason why **ggplot2** is so widely used: 
it helps minimize the amount of time required to translate a figure that exists
in your head into computer code. Note that, in the left hand plot of 
Figure \@ref(fig:worldbank), we have a time series 
of the life expectancy where each line is a country (i.e., we `group` by
country) and lines are colored by region. By clicking on a line, we also want 
the country label to appear in the right hand plot, so we also need to set 
`clickSelects=country`. Lastly, by setting `showSelected=region`,
we can hide/show lines by clicking on the color legend entries.

```{r}
timeSeries <- ggplot() + geom_line(
  data = WorldBank,
  aes(x = year, y = life.expectancy,
      group = country, color = region,
      clickSelects = country, 
      showSelected = region)
)
```

We want to provide a visual cue for the selected year in the time
series, so in the code below we add some tall rectangles to the time series plot.
These tall rectangles will also serve as a way to directly modify the
selected year. The tallrect geometry is a special case of a rectangle
that automatically spans the entire vertical range, so we just have to
specify the horizontal range via `xmin` and `xmax` aesthetics. Also, since the
layered grammar of graphics allows for different data in each layer,
we supply a data frame with just the unique years in the entire data
for this layer.

```{r}
years <- data.frame(year = unique(WorldBank$year))
timeSeries <- timeSeries + geom_tallrect(
  data = years,
  aes(xmin = year - 0.5, xmax = year + 0.5,
      clickSelects = year)
)
```

As for the right hand plot in Figure \@ref(fig:worldbank), there are 
three layers: a point layer for countries, a text layer for countries, 
and a text layer to display the selected year. By clicking on a point,
we want to display the country text label and highlight the corresponding
time series on the left hand plot, so we set `clickSelects=country`
in this layer. Furthermore, we only want to show the points for the 
selected year and region, so we also need `showSelected=year` and 
`showSelected2=region`. 

```{r}
scatterPlot <- ggplot() + geom_point(
  data = WorldBank,
  aes(x = fertility.rate, y = life.expectancy,
      color = region, size = population,
      clickSelects = country,
      showSelected = year,
      showSelected2 = region)
)
```

Note that any aesthetics containing the substring `showSelected`
(including `showSelected2`) are interpreted as `showSelected`
variables, and combined together using the intersection operation. In
the example above, that means that a point will be drawn for the
currently selected combination of year and region, as in the following SQL query,


```sql
SELECT * FROM WorldBank
  WHERE year   IN year_selection
  AND   region IN region_selection
```

Below, the text layer for
annotating selected countries is essentially the same as the point
layer, except we map the country name to the `label` aesthetic.

```{r}
scatterPlot <- scatterPlot + geom_text(
  data = WorldBank,
  aes(x = fertility.rate, y = life.expectancy,
      label = country,
      showSelected = country,
      showSelected2 = year,
      showSelected3 = region)
)
```

Lastly, to help identify the selected year when viewing the scatterplot, 
we add another layer of text at a fixed location.

```{r}
scatterPlot <- scatterPlot + geom_text(
  data = years, x = 5, y = 80,
  aes(label = paste("year =", year),
      showSelected = year)
)
```

Now that we have defined the plots in Figure \@ref(fig:worldbank), we
can set the `time` and `duration` options (introduced in Section
\@ref(animation)) to control the animation parameters. Our **animint**
implementation also respects a `selector.types` option which controls
whether or not selections for a given variable can accumulate and a
`first` option for controlling which values are selected when the visualization is first rendered
(see Table~1 for a summary of new features in **animint**).  By default,
supplying the list of plots and additional options to `animint2dir()`
will write all the files necessary to render the visualization to a
temporary directory and prompt a web browser to open an HTML file.

```{r}
viz <- list(
  timeSeries = timeSeries,
  scatterPlot = scatterPlot,
  time = list(variable = "year", ms = 3000),
  duration = list(year = 1000),
  selector.types = list(
    year = "single",
    country = "multiple",
    region = "multiple"
  ),
  first = list(
    country = c("United States", "Vietnam")
  )
)
animint2dir(viz)
```

## Adding animation {#animation}

In some sense, the `showSelected` aesthetic splits the layer into subsets
-- one for every unique value of the `showSelected` variable. The 
`clickSelects` aesthetics provides a mechanism to alter the visibility 
of those subset(s) via direct manipulation, but our system also provides a 
mechanism for automatically looping through selections to produce animation(s).
We achieve this by reserving the name `time` to specify which variable 
to select as well as the amount of time to wait before changing the selection 
(in milliseconds). We also reserve the name `duration` to specify the 
amount of time used to smoothly transition between frames (with linear easing). 


As shown in Figure \@ref(fig:design), the **animint** system is implemented
in 2 parts: the compiler and the renderer. The compiler is implemented in about 
2000 lines of R code that converts a list of ggplots and options to a JSON 
plot meta-data file and a tab-separated values (TSV) file database.

## Implementation details

```{r design, echo = FALSE, eval = TRUE, fig.cap = "A schematic explanation of compilation and rendering in the World Bank visualization. Top: the interactive animation is a list of 4 R objects: 2 ggplots and 2 option lists. Center: **animint** R code compiles data in ggplot geoms to a database of TSV files (\\textcolor{red}{$\\rightarrowtriangle$}). It also compiles plot meta-data including ggplot aesthetics, animation time options, and transition duration options to a JSON meta-data file ($\\rightarrowtriangle$). Bottom: those data-dependent compiled files are combined with data-independent JavaScript and HTML files which render the interactive animation in a web browser (\\textcolor{blue}{$\\rightarrowtriangle$})."}
knitr::include_graphics("images/figure-design.pdf")
```

As shown in Figure \@ref(fig:design), the **animint** system is
implemented in 2 parts: the compiler and the renderer. The compiler is
implemented in R code that converts a list of ggplots and options to a
JSON plot meta-data file and a tab-separated values (TSV) file
database. The renderer consists of HTML and JavaScript files, which
can be easily hosted along with the TSV and JSON files on any web
server. The interactive plots can be viewed by opening the
`index.html` page in any modern web browser. Note that our current
implementation of **animint** depends on a fork of
**ggplot2**\footnote{\url{https://github.com/faizan-khan-iit/ggplot2/tree/validate-params}}
that contains some minor modifications which are needed to support
interactive rendering on web pages. Additional implementation details
are available in the supplementary materials.


# Exploring performance & scope with examples {#performance}

This section attempts to demonstrate the range of visualizations that 
are supported by **animint** with more examples. 

## Tornadoes in the United States 

Figure \@ref(fig:tornado) depicts an interactive animation with data from 
all US tornadoes from 1950 to 2012, but graphical queries restrict focus to 
tornado paths from 1982 and tornado counts within the state of Texas. 
In the interactive version, one may (1) click on any state to view its tornado
counts throughout the years, (2) click on any bar to view the spatial 
distribution of tornado paths for that year, and (3) press play to animate
the paths throughout time. These interactive techniques can be useful for 
discovering unusual patterns or even help to suggest a reasonable model for 
describing/predicting tornado paths.

```{r tornado, echo = FALSE, eval = TRUE, fig.cap = "Interactive animation of US tornadoes from 1950 to 2012. This diagram depicts a scenario where the user queried Texas (by clicking the map), and the year 1982 (by clicking the bar chart).  In addition to the graphical elements being (automatically) highlighted as a visual clue of what query is being made, this visualization includes dynamic labels reflecting the query. Particular queries may also be stored and shared via a URL, for example: <https://bl.ocks.org/faizan-khan-iit/raw/b3912f21ec2750f96e8d1bd4b66463b2/#year={1982}state={TX}>. In this link to the interactive version, we also demonstrate the ability to dynamically rescale axes when a new query is triggered. The middle and right panel display the same data, but use different scaling: the middle panel reflects the 'global' range (US) while the right panel reflects the 'local' range (Arkansas). Futhermore, when an axis update is triggered, it smoothly transitions from one state to next (preserving object constancy in the axis ticks). This helps the viewer better perceive/understand how the range has changed from one state to the next."}
knitr::include_graphics("images/figure-tornado")
```

## Central American Climate data

```{r climate, echo = FALSE, eval = TRUE, fig.cap = "Visualization containing 6 linked, interactive, animated plots of Central American climate data. Top: for the selected time (December 1997), maps displaying the spatial distribution of two temperature variables, and a scatterplot of these two variables. The selected region is displayed with a black outline, and can be changed by clicking a rect on the map or a point on the scatterplot. Bottom: time series of the two temperature variables with the selected region shown in violet, and a scatterplot of all times for that region. The selected time can be changed by clicking a background tallrect on a time series or a point on the scatterplot. The selected region can be changed by clicking a line on a time series."}
knitr::include_graphics("images/figure-climate")
```

Figure \@ref(fig:climate) depicts an interactive animation of climate
time series data observed in Central America. Two maps display the
spatial distribution of sea surface temperature as well as its deviation 
from its monthly norm. Conditioning on a particular cell/region
highlights that region's corresponding time series below the map, 
allowing one to assess whether a particularly
low/high value at one time point remains so over time. Scatterplots
also show the relationships between the two temperature variables for
the selected time and region, allowing us to further examine how unusual
a particular query is with respect to both time and space.

Summary statistics describing complexity and performance of 
examples in this paper, as well as other **animint** examples, 
are displayed in Table \@ref(tab:examples). The climate data 
visualization has noticeably slow animations, 
since it displays about 88,980 geometric elements at once 
(<http://bit.ly/QcUrhn>). We observed
this slowdown across all browsers, which suggested that there is an
inherent bottleneck when rendering large interactive plots in web
browsers using JavaScript and SVG. Another **animint** with a similar
amount of total rows is based on the evolution data
(<http://members.cbio.ensmp.fr/~thocking/animint/evolution/viz.html>), but since it shows less data onscreen
(about 2,703 elements), it exhibits faster responses to interactivity
and animation.

**animint** is still useful for creating interactive but
non-animated plots when there is not a time variable in the data.
In fact, 7 of the 11 examples in
Table \@ref(tab:examples) are not animated. For example, linked plots
are useful to illustrate complex concepts such as a change point
detection model in the breakpoints data
(<http://members.cbio.ensmp.fr/~thocking/animint/breakpoints/viz.html>). The user can explore different model
parameters and data sets since these are encoded as **animint**
interaction variables.


\begin{table}

\caption{
Characteristics of 11 interactive visualizations designed with
    \textbf{animint}. The interactive version of these visualizations can be accessed 
    via \url{http://members.cbio.ensmp.fr/~thocking/animint/}.
    From left to right, we show the data set name and 
    Figure number in this paper (Figure), the
    lines of R code (LOC) including data processing but not including comments
    (80 characters max per line),
    the amount of time it takes to compile the visualization (seconds),
    the total size of the uncompressed TSV files in megabytes (MB),
    the total number of data points (rows),
    the median number of data points shown at once (onscreen),
    the number of data columns visualized (vars),
    the number of \texttt{clickSelects}/\texttt{showSelected} 
    variables (int),
    the number of linked panels (plots),
    if the plot is animated.
}\label{tab:examples}

\begin{tabularx}{\textwidth}{|l|l|l|l|l|l|l|l|l|l|l|}
    \hline
 Figure & LOC & seconds & MB & rows & onscreen & vars & int & plots & animated? \\ 
  \hline
  worldPop & 17 & 0.2 & 0.1 & 924 & 624 &  4 &  2 &  2 & yes  \\ 
  WorldBank \ref{fig:worldbank} & 20 & 2.3 & 2.1 & 34132 & 11611 &  6 &  2 &  2 & yes \\ 
  evolution & 25 & 21.6 & 12.0 & 240600 & 2703 &  5 &  2 &  2 & yes  \\ 
  change & 36 & 2.8 & 2.5 & 36238 & 25607 & 12 &  2 &  3 & no  \\ 
  tornado  \ref{fig:tornado} & 39 & 1.7 & 6.1 & 103691 & 16642 & 11 &  2 &  2 & no \\ 
  prior & 54 & 0.7 & 0.2 & 1960 & 142 & 12 &  3 &  4 & no  \\ 
  compare & 66 & 10.7 & 7.9 & 133958 & 2140 & 20 &  2 &  5 & no  \\ 
  breakpoints & 68 & 0.5 & 0.3 & 4242 & 667 & 13 &  2 &  3 & no  \\ 
  climate \ref{fig:climate} & 84 & 12.8 & 19.7 & 253856 & 88980 & 15 &  2 &  6 & yes \\ 
  scaffolds & 110 & 56.3 & 78.5 & 618740 & 9051 & 30 &  3 &  3 & no  \\ 
  ChIPseq & 229 & 29.9 & 78.3 & 1292464 & 1156 & 44 &  4 &  5 & no  \\
  \hline
\end{tabularx}

\end{table}



# Comparison study {#compare}

In this section we compare our **animint** implementation with other similar
leading systems by creating a given visualization in each system and
discussing the pros and cons of the different approaches.

## The Grand Tour {#tour}

The Grand Tour is a well-known method for viewing high dimensional data which
requires interactive and dynamic graphics [@grand-tour]. 
Figure \@ref(fig:tour) shows a grand tour of 300 observations sampled
from a correlated tri-variate normal distribution. The left hand view
shows the marginal density of each point while the right hand view "tours"
through 2D projections of the 3D data. There are many ways to
choose projections in a tour, and many ways to interpolate
between projections, most of which can be programmed fairly easily
using R and relevant add-on packages. In this case, we used the R package **tourr**,
which uses the geodesic random walk (i.e., random 2D projection with geodesic
interpolation) in its grand tour algorithm [@tourr].

```{r tour, echo = FALSE, eval = TRUE, fig.cap = "Linked selection in a grand tour with **animint**. A video demonstration can be viewed online at <https://vimeo.com/160720834>"}
knitr::include_graphics("images/tour")
```

When touring data, it is generally useful to link low-dimensional displays with
the tour itself. The video in Figure \@ref(fig:tour) was generated with our
current **animint** implementation, and points are selected via mouse click which
reveals that points with high marginal density are located in the
ellipsoid center while points with a low marginal density appear near the 
ellipsoid border. In this case, it would be convenient to also have brush 
selection, as we demonstrate in
Figure \@ref(fig:tourbrush) which implements the same touring example using the
R packages **ggvis** and **shiny**. The brush in Figure \@ref(fig:tourbrush) is 
implemented with **shiny**'s support for brushing static images, which currently 
does not support multiple brushes, making it difficult to select
non-contiguous regions. 

```{r tourbrush, echo = FALSE, eval = TRUE, fig.cap = "Linked selection in a grand tour with **ggvis** and **shiny**.  A video demonstration can be viewed online at <https://vimeo.com/160825528>"}
knitr::include_graphics("images/tourbrush")
```

This example helps point out a few other important differences in using 
**animint** versus **ggvis**+**shiny** to implement "multiple linked and dynamic views"
as described in @Ahlberg:1991 and @Buja:1991vh. 
Maintaining state of the linked brush in Figure \@ref(fig:tourbrush)
requires both knowledge and clever use of some sophicated programming 
techniques such as closures and reactivity. 
It also requires knowledge of the **shiny** web application framework and 
a new approach to the grammar of graphics. 
On the other hand, maintaining state in Figure \@ref(fig:tour) requires
a few different `clickSelects`/`showSelected` mappings. As a
result, we believe **animint** provides a more elegant user interface for 
this application.

The touring example also helps point out important consequences of the
design and implementation of these two different systems. As mentioned in 
Section \@ref(implementation), our current **animint** implementation requires 
every subset of data to be precomputed before render time.
For visualizations such as tours, where it is more efficient to 
perform statistical computations on-the-fly, this can be a harsh restriction, 
but this is a restriction of our current implementation 
(not a restriction of the framework itself).
As a result, when touring a large high-dimensional space, where many 
projections are needed, **ggvis**+**shiny** may be desirable since the projections are 
computed on the server and sent to the browser in real-time. This works fine
when the application is running and viewed on the same host machine, but
viewing such an application hosted on a remote machine can produce
staggered animations since client-server requests must be performed, processed,
and rendered roughly 30 times a second. Also, generally speaking, 
the **animint** system results a more pleasant experience when it comes to hosting 
and sharing applications since it doesn't require a Web Server with R and 
special software already installed.

## World Bank example

We also recreated Figure \@ref(fig:worldbank) using **ggvis**+**shiny** (see 
<http://bit.ly/1SsJKlN>) and Tableau (see 
<http://bit.ly/worldBank-tableau>). 
Even as experienced **ggvis**+**shiny** users, we found it quite difficult to
replicate this example, and were not able to completely replicate it 
due to a lack of a mechanism for coordinating indirect and direct
manipulations. Overall the visualization is pretty similar, but 
lacks a few important features. 
In particular, there is no way to control the selected
year using both the slider (indirect) and clicking on the ggvis plot (direct).
It also lacks the ability to click on a country time series and label
the corresponding point on the scatterplot. This might be possible, but we
could not find a way to update a plot based on a click event on a different
plot. Even with this lack of functionality, the **ggvis**+**shiny** is significantly
more complicated and requires more code 
(about 100 lines of code compared to 30).

<!--
% TODO: redo performance comparison
%We quantified speed differences between the two systems by timing web
%page loading using DevTools in the Chromium web browser Version
%33.0.1750.152, on Ubuntu 12.04 (256984). We also used \texttt{getTime()}
%in JavaScript to record timings for interactive plot updates (on a
%desktop computer with a 2.8GHz Intel Core i7 CPU). Using ggvis with a
%local web server and the World Bank data resulted in a web page that
%loaded quickly (about 1.4s), but updated the plot with a noticeable
%lag after each mouse click (500--1000ms). Note that since we used a
%local web server, these times represent the overhead of the web server
%system, and would be larger with a remote web server.
%
%When we used animint to make the World Bank data visualization, the
%compilation from R objects to 2.1MB of uncompressed TSV data files
%took 2.3s. Using a local web server, the animint JavaScript rendered
%the plot very quickly (100--200ms). We also observed very fast plot
%updates after mouse clicks in animint: 20--30ms response times for
%selecting the year, and 60--70ms response times for selecting the
%country.
%
%The conclusion of our speed comparison is that the overhead of waiting
%for a web server to perform computations results in significant
%slowdowns for interactive animations. It is clear that for quick
%response times, it is preferable to use an entirely JavaScript-based
%system like animint.

%% TDH 20 Nov 2014: When I click on a country on the scatterplot it
%% does not select that country's time series --- is that an inherent
%% limitation of Tableau that we should discuss?
-->

It was also impossible to completely replicate Figure \@ref(fig:worldbank)
using Tableau essentially because the example requires a \emph{layered} 
approach to the grammar of graphics. In particular, since graphical
marks and interaction source/target(s) must derive from the same table
in Tableau, it was impossible to control the clickable multiple time 
series and the clickable tallrects in different ways based on the two 
different selection variables. In other words, in Tableau, selections 
are managed on the plot level, but in **animint**, selections are specific
to each graphical layer.

# Limitations and future work {#limitations}

The system we have proposed provides linked interactive plots via the
new `showSelected` and `clickSelects` aesthetics. The linking between
plots is rather flexible, but is limited to interactions which are
specified by the plot designer at compile-time. Our current
implementation provides a visual indication of the current selection
via semi-transparency of `clickSelects` geoms. In future work we would
like to explore more obvious visual cues that can be used to quickly
show the user the links between plots and possible interactions.

A number of limitations in our current implementation derive from the
fact that some plot features are computed once during the compilation
step, and remain static on a rendered plot. For example, users are
unable to change variable mappings after compilation.  Also, when
different data subsets have very different ranges of values, it may be
preferable to recompute scales when `clickSelects` selection(s)
change. Some of these limitations can be resolved by adding
interactive widgets to "recompile" components hard-coded in the plot
meta information.  In fact, **animint** makes it easy to embed
visualizations inside of **shiny** web applications, and we have an
example of interactively redefining variable mappings
(<http://bit.ly/animint-shiny>).

Our compiler also currently takes advantage of **ggplot2** internals to compute 
statistics and positional adjustments before rendering. As a result,
statistics/positions will not dynamically recompute based on selections.
In other words, using `clickSelects`/`showSelected` with 
non-identity statistic(s)/position(s) may not generate a sensible result. 
It would be possible, but a significant amount of work, to transfer these 
computations from the compiler to the renderer.

Another set of limitations derive from our current restriction that all 
subsets (corresponding to each possible selection) must be precomputed
before render time. As elucidated in Section \@ref(tour),
if there is a large space of possible selections,
it is impractical to precompute every subset before viewing.
Therefore, for future work it would be useful if the renderer could
dynamically compute subsets when new selections are made. 

Our implementation is also limited to two specific types of
direct manipulation: selecting graphical elements via
mouse click (`clickSelects`), and showing/hiding related 
elements (`showSelected`). However, the framework described in 
Section \@ref(extension) is not restricted to a particular event type, 
so `hoverSelects` and `brushSelects` aesthetics could be 
added, for instance. There are other types of interaction that could be
added, that wouldn't require additional extensions to the grammar of graphics,
such as: zooming, panning, and plot resizing.

# Conclusion

We have proposed several extensions to **ggplot2**'s layered grammar of graphics 
in order to support a declarative approach to producing interactive
and dynamic web graphics. By adding clickSelects and showSelected aesthetics to specify selection
source(s) and target(s), **ggplot2** users can quickly and easily create 
animations with smooth transitions and perform dynamic queries via direct
manipulation of linked views. As a result, **animint** is a useful tool 
not only for EDA, but also for the presentation
and distribution of interactive statistical graphics.

\section*{Acknowledgements}

The authors wish to thank **animint** users MC Du Plessis, Song Liu,
Nikoleta Juretic, and Eric Audemard
who have contributed constructive criticism and helped its development.

\section*{References}
