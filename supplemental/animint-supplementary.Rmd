## Indirect manipulation

When viewing the interactive version of Figure \@ref(fig:worldbank), suppose
we wish to select Thailand. Direct manipulation is not very useful in 
this case since it is not easy to identify and select Thailand based
on graphical marks on a plot. For this reason, **animint** also provides 
dropdown menu(s) for each selection variable to aid the selection process.
Figure \@ref(fig:widgets) shows what the user sees after typing ''th'' in 
the search box. Note that these dropdowns support selection of multiple
values and coordinate sensibly with selections made via direct manipulation.

```{r widgets, echo = FALSE, eval = TRUE, fig.cap = "Animint provides a menu to update each selection variable. In this example, after typing \"th\" the country menu shows the subset of matching countries."}
knitr::include_graphics("images/dropdown")
```

## Additional implementation details {#implementation}

As shown in Figure \@ref(fig:design), the **animint** system is implemented
in 2 parts: the compiler and the renderer. The compiler is implemented in about 
2000 lines of R code that converts a list of ggplots and options to a JSON 
plot meta-data file and a tab-separated values (TSV) file database.


```{r design2, echo = FALSE, eval = TRUE, fig.cap = "A schematic explanation of compilation and rendering in the World Bank visualization. Top: the interactive animation is a list of 4 R objects: 2 ggplots and 2 option lists. Center: **animint** R code compiles data in ggplot geoms to a database of TSV files (\\textcolor{red}{$\\rightarrowtriangle$}). It also compiles plot meta-data including ggplot aesthetics, animation time options, and transition duration options to a JSON meta-data file ($\\rightarrowtriangle$). Bottom: those data-dependent compiled files are combined with data-independent JavaScript and HTML files which render the interactive animation in a web browser (\\textcolor{blue}{$\\rightarrowtriangle$})."}
knitr::include_graphics("images/figure-design")
```


The compiler scans the aesthetics in the ggplots to determine
how many selection variables are present, and which geoms to update
after a selection variable is updated. It uses **ggplot2** to
automatically calculate the axes scales, legends, labels, backgrounds,
and borders. It outputs this information to the JSON plot meta-data
file.

The compiler also uses **ggplot2** to convert data variables (e.g. life
expectancy and region) to visual properties (e.g. y position and
color). The data for each layer/geom are saved in several TSV files,
one for each combination `showSelected` values. Thus for large data
sets, the web browser only needs to download the subset of data
required to render the current selection [@2013-immens].

When repeated data would be saved in each of the TSV files, an extra
common TSV file is created so that the repeated data only need to be
stored and downloaded once. In that case, the other TSV files do not
store the common data, but are merged with the common data after
downloading. This method for constructing the TSV file database was
developed to minimize the disk usage of **animint**, particularly
for ggplots of spatial maps as in Figure \@ref(fig:tornado).

Finally, the rendering engine (`index.html`, `d3.v3.js`,
and `animint.js` files) is copied to the plot directory. The
`animint.js` renderer is implemented in about 2200 lines of
JavaScript/D3 code that renders the TSV and JSON data files as SVG in
a web browser. Importantly, animation is achieved by using the
JavaScript `setInterval()` function, which updates the
`time` selection variable every few seconds. Since the compiled
plot is just a directory of files, the interactive plots can be hosted
on any web server. The interactive plots can be viewed by opening the
`index.html` page in any modern web browser.

Our current implementation of **animint** depends on a fork of **ggplot2**\footnote{\url{https://github.com/faizan-khan-iit/ggplot2/tree/validate-params}}
that contains some minor modifications which are needed to support
interactive rendering on web pages.
